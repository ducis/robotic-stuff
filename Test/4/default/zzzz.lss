
zzzz.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000077e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000002  00800060  0000077e  00000812  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000050  00800062  00800062  00000814  2**0
                  ALLOC
  3 .debug_aranges 00000020  00000000  00000000  00000814  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 000000f1  00000000  00000000  00000834  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   0000033a  00000000  00000000  00000925  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000126  00000000  00000000  00000c5f  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   0000035d  00000000  00000000  00000d85  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000000b0  00000000  00000000  000010e4  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000001a4  00000000  00000000  00001194  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d4 e0       	ldi	r29, 0x04	; 4
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	ee e7       	ldi	r30, 0x7E	; 126
  68:	f7 e0       	ldi	r31, 0x07	; 7
  6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
  70:	a2 36       	cpi	r26, 0x62	; 98
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
  76:	10 e0       	ldi	r17, 0x00	; 0
  78:	a2 e6       	ldi	r26, 0x62	; 98
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	a2 3b       	cpi	r26, 0xB2	; 178
  82:	b1 07       	cpc	r27, r17
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 a5 01 	call	0x34a	; 0x34a <main>
  8a:	0c 94 bd 03 	jmp	0x77a	; 0x77a <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <Wait>:

#define SET_BIT_VALUE(byte,iBit,bValue) ((bValue)?((byte)|=_BV(iBit)):((byte)&=~_BV(iBit)))

unsigned char g_defaultThreshold = 20;

void Wait( unsigned n ){
  92:	df 93       	push	r29
  94:	cf 93       	push	r28
  96:	00 d0       	rcall	.+0      	; 0x98 <Wait+0x6>
  98:	cd b7       	in	r28, 0x3d	; 61
  9a:	de b7       	in	r29, 0x3e	; 62
  9c:	9a 83       	std	Y+2, r25	; 0x02
  9e:	89 83       	std	Y+1, r24	; 0x01
  a0:	05 c0       	rjmp	.+10     	; 0xac <Wait+0x1a>
	while( n ) --n;
  a2:	89 81       	ldd	r24, Y+1	; 0x01
  a4:	9a 81       	ldd	r25, Y+2	; 0x02
  a6:	01 97       	sbiw	r24, 0x01	; 1
  a8:	9a 83       	std	Y+2, r25	; 0x02
  aa:	89 83       	std	Y+1, r24	; 0x01
  ac:	89 81       	ldd	r24, Y+1	; 0x01
  ae:	9a 81       	ldd	r25, Y+2	; 0x02
  b0:	00 97       	sbiw	r24, 0x00	; 0
  b2:	b9 f7       	brne	.-18     	; 0xa2 <Wait+0x10>
}
  b4:	0f 90       	pop	r0
  b6:	0f 90       	pop	r0
  b8:	cf 91       	pop	r28
  ba:	df 91       	pop	r29
  bc:	08 95       	ret

000000be <UpdateRawValue>:
	unsigned char m_flags;
}g_points[NUM_POINTS];

//private:
void UpdateRawValue(struct PointState * pPoint)
{
  be:	df 93       	push	r29
  c0:	cf 93       	push	r28
  c2:	00 d0       	rcall	.+0      	; 0xc4 <UpdateRawValue+0x6>
  c4:	0f 92       	push	r0
  c6:	cd b7       	in	r28, 0x3d	; 61
  c8:	de b7       	in	r29, 0x3e	; 62
  ca:	9b 83       	std	Y+3, r25	; 0x03
  cc:	8a 83       	std	Y+2, r24	; 0x02
	unsigned char id = pPoint - g_points;
  ce:	2a 81       	ldd	r18, Y+2	; 0x02
  d0:	3b 81       	ldd	r19, Y+3	; 0x03
  d2:	82 e6       	ldi	r24, 0x62	; 98
  d4:	90 e0       	ldi	r25, 0x00	; 0
  d6:	28 1b       	sub	r18, r24
  d8:	39 0b       	sbc	r19, r25
  da:	8d ec       	ldi	r24, 0xCD	; 205
  dc:	9c ec       	ldi	r25, 0xCC	; 204
  de:	ac 01       	movw	r20, r24
  e0:	24 9f       	mul	r18, r20
  e2:	c0 01       	movw	r24, r0
  e4:	25 9f       	mul	r18, r21
  e6:	90 0d       	add	r25, r0
  e8:	34 9f       	mul	r19, r20
  ea:	90 0d       	add	r25, r0
  ec:	11 24       	eor	r1, r1
  ee:	89 83       	std	Y+1, r24	; 0x01
	PORTA = (PORTA & 15) | (id<<4);
  f0:	ab e3       	ldi	r26, 0x3B	; 59
  f2:	b0 e0       	ldi	r27, 0x00	; 0
  f4:	eb e3       	ldi	r30, 0x3B	; 59
  f6:	f0 e0       	ldi	r31, 0x00	; 0
  f8:	80 81       	ld	r24, Z
  fa:	28 2f       	mov	r18, r24
  fc:	2f 70       	andi	r18, 0x0F	; 15
  fe:	89 81       	ldd	r24, Y+1	; 0x01
 100:	88 2f       	mov	r24, r24
 102:	90 e0       	ldi	r25, 0x00	; 0
 104:	82 95       	swap	r24
 106:	92 95       	swap	r25
 108:	90 7f       	andi	r25, 0xF0	; 240
 10a:	98 27       	eor	r25, r24
 10c:	80 7f       	andi	r24, 0xF0	; 240
 10e:	98 27       	eor	r25, r24
 110:	82 2b       	or	r24, r18
 112:	8c 93       	st	X, r24
	PORTB &= ~_BV(PORTB0);
 114:	a8 e3       	ldi	r26, 0x38	; 56
 116:	b0 e0       	ldi	r27, 0x00	; 0
 118:	e8 e3       	ldi	r30, 0x38	; 56
 11a:	f0 e0       	ldi	r31, 0x00	; 0
 11c:	80 81       	ld	r24, Z
 11e:	8e 7f       	andi	r24, 0xFE	; 254
 120:	8c 93       	st	X, r24
	Wait( POINT_WAIT_BEFORE_AD );
 122:	82 e3       	ldi	r24, 0x32	; 50
 124:	90 e0       	ldi	r25, 0x00	; 0
 126:	0e 94 49 00 	call	0x92	; 0x92 <Wait>
	pPoint->m_rawValue = ADProc();
 12a:	0e 94 1e 03 	call	0x63c	; 0x63c <ADProc>
 12e:	ea 81       	ldd	r30, Y+2	; 0x02
 130:	fb 81       	ldd	r31, Y+3	; 0x03
 132:	83 83       	std	Z+3, r24	; 0x03
	PORTB |= _BV(PORTB0);
 134:	a8 e3       	ldi	r26, 0x38	; 56
 136:	b0 e0       	ldi	r27, 0x00	; 0
 138:	e8 e3       	ldi	r30, 0x38	; 56
 13a:	f0 e0       	ldi	r31, 0x00	; 0
 13c:	80 81       	ld	r24, Z
 13e:	81 60       	ori	r24, 0x01	; 1
 140:	8c 93       	st	X, r24
	Wait( POINT_WAIT_AFTER_AD );
 142:	8a e0       	ldi	r24, 0x0A	; 10
 144:	90 e0       	ldi	r25, 0x00	; 0
 146:	0e 94 49 00 	call	0x92	; 0x92 <Wait>
}
 14a:	0f 90       	pop	r0
 14c:	0f 90       	pop	r0
 14e:	0f 90       	pop	r0
 150:	cf 91       	pop	r28
 152:	df 91       	pop	r29
 154:	08 95       	ret

00000156 <UpdatePointState>:
//public:
void UpdatePointState(struct PointState * pPoint)
{
 156:	df 93       	push	r29
 158:	cf 93       	push	r28
 15a:	00 d0       	rcall	.+0      	; 0x15c <UpdatePointState+0x6>
 15c:	cd b7       	in	r28, 0x3d	; 61
 15e:	de b7       	in	r29, 0x3e	; 62
 160:	9a 83       	std	Y+2, r25	; 0x02
 162:	89 83       	std	Y+1, r24	; 0x01
	UpdateRawValue(pPoint);
 164:	89 81       	ldd	r24, Y+1	; 0x01
 166:	9a 81       	ldd	r25, Y+2	; 0x02
 168:	0e 94 5f 00 	call	0xbe	; 0xbe <UpdateRawValue>
	if(pPoint->m_rawValue>pPoint->m_threshold)//g_whiteThreshold)
 16c:	e9 81       	ldd	r30, Y+1	; 0x01
 16e:	fa 81       	ldd	r31, Y+2	; 0x02
 170:	93 81       	ldd	r25, Z+3	; 0x03
 172:	e9 81       	ldd	r30, Y+1	; 0x01
 174:	fa 81       	ldd	r31, Y+2	; 0x02
 176:	82 81       	ldd	r24, Z+2	; 0x02
 178:	89 17       	cp	r24, r25
 17a:	40 f4       	brcc	.+16     	; 0x18c <UpdatePointState+0x36>
		pPoint->m_flags |=POINT_IS_WHITE_BIT;
 17c:	e9 81       	ldd	r30, Y+1	; 0x01
 17e:	fa 81       	ldd	r31, Y+2	; 0x02
 180:	84 81       	ldd	r24, Z+4	; 0x04
 182:	81 60       	ori	r24, 0x01	; 1
 184:	e9 81       	ldd	r30, Y+1	; 0x01
 186:	fa 81       	ldd	r31, Y+2	; 0x02
 188:	84 83       	std	Z+4, r24	; 0x04
 18a:	07 c0       	rjmp	.+14     	; 0x19a <UpdatePointState+0x44>
	else 
		pPoint->m_flags &=~POINT_IS_WHITE_BIT;
 18c:	e9 81       	ldd	r30, Y+1	; 0x01
 18e:	fa 81       	ldd	r31, Y+2	; 0x02
 190:	84 81       	ldd	r24, Z+4	; 0x04
 192:	8e 7f       	andi	r24, 0xFE	; 254
 194:	e9 81       	ldd	r30, Y+1	; 0x01
 196:	fa 81       	ldd	r31, Y+2	; 0x02
 198:	84 83       	std	Z+4, r24	; 0x04
}
 19a:	0f 90       	pop	r0
 19c:	0f 90       	pop	r0
 19e:	cf 91       	pop	r28
 1a0:	df 91       	pop	r29
 1a2:	08 95       	ret

000001a4 <UpdateMinMax>:

void UpdateMinMax(struct PointState *pPoint)
{
 1a4:	df 93       	push	r29
 1a6:	cf 93       	push	r28
 1a8:	00 d0       	rcall	.+0      	; 0x1aa <UpdateMinMax+0x6>
 1aa:	cd b7       	in	r28, 0x3d	; 61
 1ac:	de b7       	in	r29, 0x3e	; 62
 1ae:	9a 83       	std	Y+2, r25	; 0x02
 1b0:	89 83       	std	Y+1, r24	; 0x01
	UpdateRawValue(pPoint);
 1b2:	89 81       	ldd	r24, Y+1	; 0x01
 1b4:	9a 81       	ldd	r25, Y+2	; 0x02
 1b6:	0e 94 5f 00 	call	0xbe	; 0xbe <UpdateRawValue>
	if(pPoint->m_rawValue<pPoint->m_minimum)	pPoint->m_minimum = pPoint->m_rawValue;
 1ba:	e9 81       	ldd	r30, Y+1	; 0x01
 1bc:	fa 81       	ldd	r31, Y+2	; 0x02
 1be:	93 81       	ldd	r25, Z+3	; 0x03
 1c0:	e9 81       	ldd	r30, Y+1	; 0x01
 1c2:	fa 81       	ldd	r31, Y+2	; 0x02
 1c4:	80 81       	ld	r24, Z
 1c6:	98 17       	cp	r25, r24
 1c8:	30 f4       	brcc	.+12     	; 0x1d6 <UpdateMinMax+0x32>
 1ca:	e9 81       	ldd	r30, Y+1	; 0x01
 1cc:	fa 81       	ldd	r31, Y+2	; 0x02
 1ce:	83 81       	ldd	r24, Z+3	; 0x03
 1d0:	e9 81       	ldd	r30, Y+1	; 0x01
 1d2:	fa 81       	ldd	r31, Y+2	; 0x02
 1d4:	80 83       	st	Z, r24
	if(pPoint->m_rawValue>pPoint->m_maximum)	pPoint->m_maximum = pPoint->m_rawValue;
 1d6:	e9 81       	ldd	r30, Y+1	; 0x01
 1d8:	fa 81       	ldd	r31, Y+2	; 0x02
 1da:	93 81       	ldd	r25, Z+3	; 0x03
 1dc:	e9 81       	ldd	r30, Y+1	; 0x01
 1de:	fa 81       	ldd	r31, Y+2	; 0x02
 1e0:	81 81       	ldd	r24, Z+1	; 0x01
 1e2:	89 17       	cp	r24, r25
 1e4:	30 f4       	brcc	.+12     	; 0x1f2 <UpdateMinMax+0x4e>
 1e6:	e9 81       	ldd	r30, Y+1	; 0x01
 1e8:	fa 81       	ldd	r31, Y+2	; 0x02
 1ea:	83 81       	ldd	r24, Z+3	; 0x03
 1ec:	e9 81       	ldd	r30, Y+1	; 0x01
 1ee:	fa 81       	ldd	r31, Y+2	; 0x02
 1f0:	81 83       	std	Z+1, r24	; 0x01
}
 1f2:	0f 90       	pop	r0
 1f4:	0f 90       	pop	r0
 1f6:	cf 91       	pop	r28
 1f8:	df 91       	pop	r29
 1fa:	08 95       	ret

000001fc <ComputeThreshold>:

void ComputeThreshold(struct PointState *pPoint)
{
 1fc:	df 93       	push	r29
 1fe:	cf 93       	push	r28
 200:	00 d0       	rcall	.+0      	; 0x202 <ComputeThreshold+0x6>
 202:	cd b7       	in	r28, 0x3d	; 61
 204:	de b7       	in	r29, 0x3e	; 62
 206:	9a 83       	std	Y+2, r25	; 0x02
 208:	89 83       	std	Y+1, r24	; 0x01
	pPoint->m_threshold = ((long)pPoint->m_minimum+(long)pPoint->m_maximum)*THRESHOLD_RATIO/255;
 20a:	e9 81       	ldd	r30, Y+1	; 0x01
 20c:	fa 81       	ldd	r31, Y+2	; 0x02
 20e:	80 81       	ld	r24, Z
 210:	28 2f       	mov	r18, r24
 212:	30 e0       	ldi	r19, 0x00	; 0
 214:	40 e0       	ldi	r20, 0x00	; 0
 216:	50 e0       	ldi	r21, 0x00	; 0
 218:	e9 81       	ldd	r30, Y+1	; 0x01
 21a:	fa 81       	ldd	r31, Y+2	; 0x02
 21c:	81 81       	ldd	r24, Z+1	; 0x01
 21e:	88 2f       	mov	r24, r24
 220:	90 e0       	ldi	r25, 0x00	; 0
 222:	a0 e0       	ldi	r26, 0x00	; 0
 224:	b0 e0       	ldi	r27, 0x00	; 0
 226:	82 0f       	add	r24, r18
 228:	93 1f       	adc	r25, r19
 22a:	a4 1f       	adc	r26, r20
 22c:	b5 1f       	adc	r27, r21
 22e:	2c e3       	ldi	r18, 0x3C	; 60
 230:	30 e0       	ldi	r19, 0x00	; 0
 232:	40 e0       	ldi	r20, 0x00	; 0
 234:	50 e0       	ldi	r21, 0x00	; 0
 236:	bc 01       	movw	r22, r24
 238:	cd 01       	movw	r24, r26
 23a:	0e 94 3a 03 	call	0x674	; 0x674 <__mulsi3>
 23e:	dc 01       	movw	r26, r24
 240:	cb 01       	movw	r24, r22
 242:	2f ef       	ldi	r18, 0xFF	; 255
 244:	30 e0       	ldi	r19, 0x00	; 0
 246:	40 e0       	ldi	r20, 0x00	; 0
 248:	50 e0       	ldi	r21, 0x00	; 0
 24a:	bc 01       	movw	r22, r24
 24c:	cd 01       	movw	r24, r26
 24e:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <__divmodsi4>
 252:	da 01       	movw	r26, r20
 254:	c9 01       	movw	r24, r18
 256:	e9 81       	ldd	r30, Y+1	; 0x01
 258:	fa 81       	ldd	r31, Y+2	; 0x02
 25a:	82 83       	std	Z+2, r24	; 0x02
}
 25c:	0f 90       	pop	r0
 25e:	0f 90       	pop	r0
 260:	cf 91       	pop	r28
 262:	df 91       	pop	r29
 264:	08 95       	ret

00000266 <UseDefaultThreshold>:

void UseDefaultThreshold(struct PointState *pPoint)
{
 266:	df 93       	push	r29
 268:	cf 93       	push	r28
 26a:	00 d0       	rcall	.+0      	; 0x26c <UseDefaultThreshold+0x6>
 26c:	cd b7       	in	r28, 0x3d	; 61
 26e:	de b7       	in	r29, 0x3e	; 62
 270:	9a 83       	std	Y+2, r25	; 0x02
 272:	89 83       	std	Y+1, r24	; 0x01
	pPoint->m_threshold = g_defaultThreshold;
 274:	80 91 60 00 	lds	r24, 0x0060
 278:	e9 81       	ldd	r30, Y+1	; 0x01
 27a:	fa 81       	ldd	r31, Y+2	; 0x02
 27c:	82 83       	std	Z+2, r24	; 0x02
}
 27e:	0f 90       	pop	r0
 280:	0f 90       	pop	r0
 282:	cf 91       	pop	r28
 284:	df 91       	pop	r29
 286:	08 95       	ret

00000288 <ConstructPointState>:

//Ctor
void ConstructPointState(struct PointState *pPoint)
{
 288:	df 93       	push	r29
 28a:	cf 93       	push	r28
 28c:	00 d0       	rcall	.+0      	; 0x28e <ConstructPointState+0x6>
 28e:	cd b7       	in	r28, 0x3d	; 61
 290:	de b7       	in	r29, 0x3e	; 62
 292:	9a 83       	std	Y+2, r25	; 0x02
 294:	89 83       	std	Y+1, r24	; 0x01
	pPoint->m_minimum = 255;
 296:	e9 81       	ldd	r30, Y+1	; 0x01
 298:	fa 81       	ldd	r31, Y+2	; 0x02
 29a:	8f ef       	ldi	r24, 0xFF	; 255
 29c:	80 83       	st	Z, r24
	pPoint->m_maximum = 0;
 29e:	e9 81       	ldd	r30, Y+1	; 0x01
 2a0:	fa 81       	ldd	r31, Y+2	; 0x02
 2a2:	11 82       	std	Z+1, r1	; 0x01
	pPoint->m_flags = 0;
 2a4:	e9 81       	ldd	r30, Y+1	; 0x01
 2a6:	fa 81       	ldd	r31, Y+2	; 0x02
 2a8:	14 82       	std	Z+4, r1	; 0x04
	pPoint->m_threshold = g_defaultThreshold;
 2aa:	80 91 60 00 	lds	r24, 0x0060
 2ae:	e9 81       	ldd	r30, Y+1	; 0x01
 2b0:	fa 81       	ldd	r31, Y+2	; 0x02
 2b2:	82 83       	std	Z+2, r24	; 0x02
}
 2b4:	0f 90       	pop	r0
 2b6:	0f 90       	pop	r0
 2b8:	cf 91       	pop	r28
 2ba:	df 91       	pop	r29
 2bc:	08 95       	ret

000002be <WriteByteToTheShiftRegister>:

//END PointState;


void WriteByteToTheShiftRegister(unsigned char b){
 2be:	df 93       	push	r29
 2c0:	cf 93       	push	r28
 2c2:	00 d0       	rcall	.+0      	; 0x2c4 <WriteByteToTheShiftRegister+0x6>
 2c4:	00 d0       	rcall	.+0      	; 0x2c6 <WriteByteToTheShiftRegister+0x8>
 2c6:	0f 92       	push	r0
 2c8:	cd b7       	in	r28, 0x3d	; 61
 2ca:	de b7       	in	r29, 0x3e	; 62
 2cc:	8b 83       	std	Y+3, r24	; 0x03
	int i;
	for(i=0;i<8;++i){
 2ce:	1a 82       	std	Y+2, r1	; 0x02
 2d0:	19 82       	std	Y+1, r1	; 0x01
 2d2:	2e c0       	rjmp	.+92     	; 0x330 <WriteByteToTheShiftRegister+0x72>
		PORTB&=~_BV(PORTB1);
 2d4:	a8 e3       	ldi	r26, 0x38	; 56
 2d6:	b0 e0       	ldi	r27, 0x00	; 0
 2d8:	e8 e3       	ldi	r30, 0x38	; 56
 2da:	f0 e0       	ldi	r31, 0x00	; 0
 2dc:	80 81       	ld	r24, Z
 2de:	8d 7f       	andi	r24, 0xFD	; 253
 2e0:	8c 93       	st	X, r24
		SET_BIT_VALUE(PORTB,PORTB2,b&1);
 2e2:	8b 81       	ldd	r24, Y+3	; 0x03
 2e4:	88 2f       	mov	r24, r24
 2e6:	90 e0       	ldi	r25, 0x00	; 0
 2e8:	81 70       	andi	r24, 0x01	; 1
 2ea:	90 70       	andi	r25, 0x00	; 0
 2ec:	88 23       	and	r24, r24
 2ee:	49 f0       	breq	.+18     	; 0x302 <WriteByteToTheShiftRegister+0x44>
 2f0:	a8 e3       	ldi	r26, 0x38	; 56
 2f2:	b0 e0       	ldi	r27, 0x00	; 0
 2f4:	e8 e3       	ldi	r30, 0x38	; 56
 2f6:	f0 e0       	ldi	r31, 0x00	; 0
 2f8:	80 81       	ld	r24, Z
 2fa:	84 60       	ori	r24, 0x04	; 4
 2fc:	8c 93       	st	X, r24
 2fe:	8c 91       	ld	r24, X
 300:	08 c0       	rjmp	.+16     	; 0x312 <WriteByteToTheShiftRegister+0x54>
 302:	a8 e3       	ldi	r26, 0x38	; 56
 304:	b0 e0       	ldi	r27, 0x00	; 0
 306:	e8 e3       	ldi	r30, 0x38	; 56
 308:	f0 e0       	ldi	r31, 0x00	; 0
 30a:	80 81       	ld	r24, Z
 30c:	8b 7f       	andi	r24, 0xFB	; 251
 30e:	8c 93       	st	X, r24
 310:	8c 91       	ld	r24, X
		//Wait(SHIFT_REGISTER_CLK_SETUP);
		PORTB|=_BV(PORTB1);
 312:	a8 e3       	ldi	r26, 0x38	; 56
 314:	b0 e0       	ldi	r27, 0x00	; 0
 316:	e8 e3       	ldi	r30, 0x38	; 56
 318:	f0 e0       	ldi	r31, 0x00	; 0
 31a:	80 81       	ld	r24, Z
 31c:	82 60       	ori	r24, 0x02	; 2
 31e:	8c 93       	st	X, r24
		//Wait(SHIFT_REGISTER_CLK_HOLD);
		b>>=1;
 320:	8b 81       	ldd	r24, Y+3	; 0x03
 322:	86 95       	lsr	r24
 324:	8b 83       	std	Y+3, r24	; 0x03
//END PointState;


void WriteByteToTheShiftRegister(unsigned char b){
	int i;
	for(i=0;i<8;++i){
 326:	89 81       	ldd	r24, Y+1	; 0x01
 328:	9a 81       	ldd	r25, Y+2	; 0x02
 32a:	01 96       	adiw	r24, 0x01	; 1
 32c:	9a 83       	std	Y+2, r25	; 0x02
 32e:	89 83       	std	Y+1, r24	; 0x01
 330:	89 81       	ldd	r24, Y+1	; 0x01
 332:	9a 81       	ldd	r25, Y+2	; 0x02
 334:	88 30       	cpi	r24, 0x08	; 8
 336:	91 05       	cpc	r25, r1
 338:	6c f2       	brlt	.-102    	; 0x2d4 <WriteByteToTheShiftRegister+0x16>
		//Wait(SHIFT_REGISTER_CLK_SETUP);
		PORTB|=_BV(PORTB1);
		//Wait(SHIFT_REGISTER_CLK_HOLD);
		b>>=1;
	}
}
 33a:	0f 90       	pop	r0
 33c:	0f 90       	pop	r0
 33e:	0f 90       	pop	r0
 340:	0f 90       	pop	r0
 342:	0f 90       	pop	r0
 344:	cf 91       	pop	r28
 346:	df 91       	pop	r29
 348:	08 95       	ret

0000034a <main>:
int main(){
 34a:	df 93       	push	r29
 34c:	cf 93       	push	r28
 34e:	cd b7       	in	r28, 0x3d	; 61
 350:	de b7       	in	r29, 0x3e	; 62
 352:	2f 97       	sbiw	r28, 0x0f	; 15
 354:	0f b6       	in	r0, 0x3f	; 63
 356:	f8 94       	cli
 358:	de bf       	out	0x3e, r29	; 62
 35a:	0f be       	out	0x3f, r0	; 63
 35c:	cd bf       	out	0x3d, r28	; 61
	//sbi(TCCR0,FOC0);
	//TCCR0|=_BV(FOC0);
	{
		DDRB = _BV(DDB0)|_BV(DDB1)|_BV(DDB2)|_BV(DDB3);
 35e:	e7 e3       	ldi	r30, 0x37	; 55
 360:	f0 e0       	ldi	r31, 0x00	; 0
 362:	8f e0       	ldi	r24, 0x0F	; 15
 364:	80 83       	st	Z, r24
		PORTB = _BV(PORTB0);
 366:	e8 e3       	ldi	r30, 0x38	; 56
 368:	f0 e0       	ldi	r31, 0x00	; 0
 36a:	81 e0       	ldi	r24, 0x01	; 1
 36c:	80 83       	st	Z, r24

		TCCR0 = _BV(WGM01)|_BV(COM00)|_BV(CS01)|_BV(CS00);
 36e:	e3 e5       	ldi	r30, 0x53	; 83
 370:	f0 e0       	ldi	r31, 0x00	; 0
 372:	8b e1       	ldi	r24, 0x1B	; 27
 374:	80 83       	st	Z, r24
		TCNT0 = 0;
 376:	e2 e5       	ldi	r30, 0x52	; 82
 378:	f0 e0       	ldi	r31, 0x00	; 0
 37a:	10 82       	st	Z, r1
		OCR0 = FREQ_MODIFIER;//62;
 37c:	ec e5       	ldi	r30, 0x5C	; 92
 37e:	f0 e0       	ldi	r31, 0x00	; 0
 380:	82 e4       	ldi	r24, 0x42	; 66
 382:	80 83       	st	Z, r24
		TIMSK = 0;
 384:	e9 e5       	ldi	r30, 0x59	; 89
 386:	f0 e0       	ldi	r31, 0x00	; 0
 388:	10 82       	st	Z, r1
		TIFR = 0;
 38a:	e8 e5       	ldi	r30, 0x58	; 88
 38c:	f0 e0       	ldi	r31, 0x00	; 0
 38e:	10 82       	st	Z, r1

		DDRA = _BV(DDA4)|_BV(DDA5)|_BV(DDA6)|_BV(DDA7);
 390:	ea e3       	ldi	r30, 0x3A	; 58
 392:	f0 e0       	ldi	r31, 0x00	; 0
 394:	80 ef       	ldi	r24, 0xF0	; 240
 396:	80 83       	st	Z, r24
		PORTA = 0;
 398:	eb e3       	ldi	r30, 0x3B	; 59
 39a:	f0 e0       	ldi	r31, 0x00	; 0
 39c:	10 82       	st	Z, r1

		DDRC = 0;
 39e:	e4 e3       	ldi	r30, 0x34	; 52
 3a0:	f0 e0       	ldi	r31, 0x00	; 0
 3a2:	10 82       	st	Z, r1
		PORTC = 0;
 3a4:	e5 e3       	ldi	r30, 0x35	; 53
 3a6:	f0 e0       	ldi	r31, 0x00	; 0
 3a8:	10 82       	st	Z, r1

		//AD Converter
		ADMUX = _BV(REFS0)|_BV(ADLAR);
 3aa:	e7 e2       	ldi	r30, 0x27	; 39
 3ac:	f0 e0       	ldi	r31, 0x00	; 0
 3ae:	80 e6       	ldi	r24, 0x60	; 96
 3b0:	80 83       	st	Z, r24
		ADCSRA = _BV(ADEN);
 3b2:	e6 e2       	ldi	r30, 0x26	; 38
 3b4:	f0 e0       	ldi	r31, 0x00	; 0
 3b6:	80 e8       	ldi	r24, 0x80	; 128
 3b8:	80 83       	st	Z, r24
		STATE_INIT,
		STATE_IDLE,
		STATE_CALIBERATING,
		STATE_NORMAL,		
		NUM_STATES
	}currentState = STATE_INIT;
 3ba:	1b 86       	std	Y+11, r1	; 0x0b

	while(1){
		switch(currentState){
 3bc:	8b 85       	ldd	r24, Y+11	; 0x0b
 3be:	28 2f       	mov	r18, r24
 3c0:	30 e0       	ldi	r19, 0x00	; 0
 3c2:	3d 87       	std	Y+13, r19	; 0x0d
 3c4:	2c 87       	std	Y+12, r18	; 0x0c
 3c6:	4c 85       	ldd	r20, Y+12	; 0x0c
 3c8:	5d 85       	ldd	r21, Y+13	; 0x0d
 3ca:	41 30       	cpi	r20, 0x01	; 1
 3cc:	51 05       	cpc	r21, r1
 3ce:	d9 f1       	breq	.+118    	; 0x446 <main+0xfc>
 3d0:	8c 85       	ldd	r24, Y+12	; 0x0c
 3d2:	9d 85       	ldd	r25, Y+13	; 0x0d
 3d4:	82 30       	cpi	r24, 0x02	; 2
 3d6:	91 05       	cpc	r25, r1
 3d8:	34 f4       	brge	.+12     	; 0x3e6 <main+0x9c>
 3da:	2c 85       	ldd	r18, Y+12	; 0x0c
 3dc:	3d 85       	ldd	r19, Y+13	; 0x0d
 3de:	21 15       	cp	r18, r1
 3e0:	31 05       	cpc	r19, r1
 3e2:	71 f0       	breq	.+28     	; 0x400 <main+0xb6>
 3e4:	eb cf       	rjmp	.-42     	; 0x3bc <main+0x72>
 3e6:	4c 85       	ldd	r20, Y+12	; 0x0c
 3e8:	5d 85       	ldd	r21, Y+13	; 0x0d
 3ea:	42 30       	cpi	r20, 0x02	; 2
 3ec:	51 05       	cpc	r21, r1
 3ee:	09 f4       	brne	.+2      	; 0x3f2 <main+0xa8>
 3f0:	5c c0       	rjmp	.+184    	; 0x4aa <__stack+0x4b>
 3f2:	8c 85       	ldd	r24, Y+12	; 0x0c
 3f4:	9d 85       	ldd	r25, Y+13	; 0x0d
 3f6:	83 30       	cpi	r24, 0x03	; 3
 3f8:	91 05       	cpc	r25, r1
 3fa:	09 f4       	brne	.+2      	; 0x3fe <main+0xb4>
 3fc:	97 c0       	rjmp	.+302    	; 0x52c <__stack+0xcd>
 3fe:	de cf       	rjmp	.-68     	; 0x3bc <main+0x72>
		case STATE_INIT:
			{
				int i;
				for(i=0; i<NUM_POINTS; ++i){
 400:	1a 86       	std	Y+10, r1	; 0x0a
 402:	19 86       	std	Y+9, r1	; 0x09
 404:	12 c0       	rjmp	.+36     	; 0x42a <main+0xe0>
					ConstructPointState(g_points+i);
 406:	29 85       	ldd	r18, Y+9	; 0x09
 408:	3a 85       	ldd	r19, Y+10	; 0x0a
 40a:	c9 01       	movw	r24, r18
 40c:	88 0f       	add	r24, r24
 40e:	99 1f       	adc	r25, r25
 410:	88 0f       	add	r24, r24
 412:	99 1f       	adc	r25, r25
 414:	82 0f       	add	r24, r18
 416:	93 1f       	adc	r25, r19
 418:	8e 59       	subi	r24, 0x9E	; 158
 41a:	9f 4f       	sbci	r25, 0xFF	; 255
 41c:	0e 94 44 01 	call	0x288	; 0x288 <ConstructPointState>
	while(1){
		switch(currentState){
		case STATE_INIT:
			{
				int i;
				for(i=0; i<NUM_POINTS; ++i){
 420:	89 85       	ldd	r24, Y+9	; 0x09
 422:	9a 85       	ldd	r25, Y+10	; 0x0a
 424:	01 96       	adiw	r24, 0x01	; 1
 426:	9a 87       	std	Y+10, r25	; 0x0a
 428:	89 87       	std	Y+9, r24	; 0x09
 42a:	89 85       	ldd	r24, Y+9	; 0x09
 42c:	9a 85       	ldd	r25, Y+10	; 0x0a
 42e:	80 31       	cpi	r24, 0x10	; 16
 430:	91 05       	cpc	r25, r1
 432:	4c f3       	brlt	.-46     	; 0x406 <main+0xbc>
					ConstructPointState(g_points+i);
				}
				WriteByteToTheShiftRegister(0);
 434:	80 e0       	ldi	r24, 0x00	; 0
 436:	0e 94 5f 01 	call	0x2be	; 0x2be <WriteByteToTheShiftRegister>
				WriteByteToTheShiftRegister(0);
 43a:	80 e0       	ldi	r24, 0x00	; 0
 43c:	0e 94 5f 01 	call	0x2be	; 0x2be <WriteByteToTheShiftRegister>
				currentState = STATE_IDLE;
 440:	81 e0       	ldi	r24, 0x01	; 1
 442:	8b 87       	std	Y+11, r24	; 0x0b
 444:	bb cf       	rjmp	.-138    	; 0x3bc <main+0x72>
			}
			break;
		case STATE_IDLE:
			{
				if( !(PINC&_BV(PINC0)) ){//Press S1 to caliberate
 446:	e3 e3       	ldi	r30, 0x33	; 51
 448:	f0 e0       	ldi	r31, 0x00	; 0
 44a:	80 81       	ld	r24, Z
 44c:	88 2f       	mov	r24, r24
 44e:	90 e0       	ldi	r25, 0x00	; 0
 450:	81 70       	andi	r24, 0x01	; 1
 452:	90 70       	andi	r25, 0x00	; 0
 454:	00 97       	sbiw	r24, 0x00	; 0
 456:	11 f4       	brne	.+4      	; 0x45c <main+0x112>
					currentState = STATE_CALIBERATING;
 458:	82 e0       	ldi	r24, 0x02	; 2
 45a:	8b 87       	std	Y+11, r24	; 0x0b
				}
				if( !(PINC&_BV(PINC1)) ){//Press S2 to scan using default threshold
 45c:	e3 e3       	ldi	r30, 0x33	; 51
 45e:	f0 e0       	ldi	r31, 0x00	; 0
 460:	80 81       	ld	r24, Z
 462:	88 2f       	mov	r24, r24
 464:	90 e0       	ldi	r25, 0x00	; 0
 466:	82 70       	andi	r24, 0x02	; 2
 468:	90 70       	andi	r25, 0x00	; 0
 46a:	00 97       	sbiw	r24, 0x00	; 0
 46c:	09 f0       	breq	.+2      	; 0x470 <__stack+0x11>
 46e:	a6 cf       	rjmp	.-180    	; 0x3bc <main+0x72>
					int i;
					for( i=0; i<NUM_POINTS; ++i ){
 470:	18 86       	std	Y+8, r1	; 0x08
 472:	1f 82       	std	Y+7, r1	; 0x07
 474:	12 c0       	rjmp	.+36     	; 0x49a <__stack+0x3b>
						UseDefaultThreshold(g_points+i);
 476:	2f 81       	ldd	r18, Y+7	; 0x07
 478:	38 85       	ldd	r19, Y+8	; 0x08
 47a:	c9 01       	movw	r24, r18
 47c:	88 0f       	add	r24, r24
 47e:	99 1f       	adc	r25, r25
 480:	88 0f       	add	r24, r24
 482:	99 1f       	adc	r25, r25
 484:	82 0f       	add	r24, r18
 486:	93 1f       	adc	r25, r19
 488:	8e 59       	subi	r24, 0x9E	; 158
 48a:	9f 4f       	sbci	r25, 0xFF	; 255
 48c:	0e 94 33 01 	call	0x266	; 0x266 <UseDefaultThreshold>
				if( !(PINC&_BV(PINC0)) ){//Press S1 to caliberate
					currentState = STATE_CALIBERATING;
				}
				if( !(PINC&_BV(PINC1)) ){//Press S2 to scan using default threshold
					int i;
					for( i=0; i<NUM_POINTS; ++i ){
 490:	8f 81       	ldd	r24, Y+7	; 0x07
 492:	98 85       	ldd	r25, Y+8	; 0x08
 494:	01 96       	adiw	r24, 0x01	; 1
 496:	98 87       	std	Y+8, r25	; 0x08
 498:	8f 83       	std	Y+7, r24	; 0x07
 49a:	8f 81       	ldd	r24, Y+7	; 0x07
 49c:	98 85       	ldd	r25, Y+8	; 0x08
 49e:	80 31       	cpi	r24, 0x10	; 16
 4a0:	91 05       	cpc	r25, r1
 4a2:	4c f3       	brlt	.-46     	; 0x476 <__stack+0x17>
						UseDefaultThreshold(g_points+i);
					}
					currentState = STATE_NORMAL;
 4a4:	83 e0       	ldi	r24, 0x03	; 3
 4a6:	8b 87       	std	Y+11, r24	; 0x0b
 4a8:	89 cf       	rjmp	.-238    	; 0x3bc <main+0x72>
			}
			break;
		case STATE_CALIBERATING:
			{
				int i;
				for(i=0; i<NUM_POINTS; ++i){
 4aa:	1e 82       	std	Y+6, r1	; 0x06
 4ac:	1d 82       	std	Y+5, r1	; 0x05
 4ae:	12 c0       	rjmp	.+36     	; 0x4d4 <__stack+0x75>
					UpdateMinMax(g_points+i);
 4b0:	2d 81       	ldd	r18, Y+5	; 0x05
 4b2:	3e 81       	ldd	r19, Y+6	; 0x06
 4b4:	c9 01       	movw	r24, r18
 4b6:	88 0f       	add	r24, r24
 4b8:	99 1f       	adc	r25, r25
 4ba:	88 0f       	add	r24, r24
 4bc:	99 1f       	adc	r25, r25
 4be:	82 0f       	add	r24, r18
 4c0:	93 1f       	adc	r25, r19
 4c2:	8e 59       	subi	r24, 0x9E	; 158
 4c4:	9f 4f       	sbci	r25, 0xFF	; 255
 4c6:	0e 94 d2 00 	call	0x1a4	; 0x1a4 <UpdateMinMax>
			}
			break;
		case STATE_CALIBERATING:
			{
				int i;
				for(i=0; i<NUM_POINTS; ++i){
 4ca:	8d 81       	ldd	r24, Y+5	; 0x05
 4cc:	9e 81       	ldd	r25, Y+6	; 0x06
 4ce:	01 96       	adiw	r24, 0x01	; 1
 4d0:	9e 83       	std	Y+6, r25	; 0x06
 4d2:	8d 83       	std	Y+5, r24	; 0x05
 4d4:	8d 81       	ldd	r24, Y+5	; 0x05
 4d6:	9e 81       	ldd	r25, Y+6	; 0x06
 4d8:	80 31       	cpi	r24, 0x10	; 16
 4da:	91 05       	cpc	r25, r1
 4dc:	4c f3       	brlt	.-46     	; 0x4b0 <__stack+0x51>
					UpdateMinMax(g_points+i);
				}
				if(PINC&_BV(PINC0)){
 4de:	e3 e3       	ldi	r30, 0x33	; 51
 4e0:	f0 e0       	ldi	r31, 0x00	; 0
 4e2:	80 81       	ld	r24, Z
 4e4:	88 2f       	mov	r24, r24
 4e6:	90 e0       	ldi	r25, 0x00	; 0
 4e8:	81 70       	andi	r24, 0x01	; 1
 4ea:	90 70       	andi	r25, 0x00	; 0
 4ec:	88 23       	and	r24, r24
 4ee:	09 f4       	brne	.+2      	; 0x4f2 <__stack+0x93>
 4f0:	65 cf       	rjmp	.-310    	; 0x3bc <main+0x72>
					for(i=0; i<NUM_POINTS; ++i){
 4f2:	1e 82       	std	Y+6, r1	; 0x06
 4f4:	1d 82       	std	Y+5, r1	; 0x05
 4f6:	12 c0       	rjmp	.+36     	; 0x51c <__stack+0xbd>
						ComputeThreshold(g_points+i);
 4f8:	2d 81       	ldd	r18, Y+5	; 0x05
 4fa:	3e 81       	ldd	r19, Y+6	; 0x06
 4fc:	c9 01       	movw	r24, r18
 4fe:	88 0f       	add	r24, r24
 500:	99 1f       	adc	r25, r25
 502:	88 0f       	add	r24, r24
 504:	99 1f       	adc	r25, r25
 506:	82 0f       	add	r24, r18
 508:	93 1f       	adc	r25, r19
 50a:	8e 59       	subi	r24, 0x9E	; 158
 50c:	9f 4f       	sbci	r25, 0xFF	; 255
 50e:	0e 94 fe 00 	call	0x1fc	; 0x1fc <ComputeThreshold>
				int i;
				for(i=0; i<NUM_POINTS; ++i){
					UpdateMinMax(g_points+i);
				}
				if(PINC&_BV(PINC0)){
					for(i=0; i<NUM_POINTS; ++i){
 512:	8d 81       	ldd	r24, Y+5	; 0x05
 514:	9e 81       	ldd	r25, Y+6	; 0x06
 516:	01 96       	adiw	r24, 0x01	; 1
 518:	9e 83       	std	Y+6, r25	; 0x06
 51a:	8d 83       	std	Y+5, r24	; 0x05
 51c:	8d 81       	ldd	r24, Y+5	; 0x05
 51e:	9e 81       	ldd	r25, Y+6	; 0x06
 520:	80 31       	cpi	r24, 0x10	; 16
 522:	91 05       	cpc	r25, r1
 524:	4c f3       	brlt	.-46     	; 0x4f8 <__stack+0x99>
						ComputeThreshold(g_points+i);
					}
					currentState = STATE_NORMAL;
 526:	83 e0       	ldi	r24, 0x03	; 3
 528:	8b 87       	std	Y+11, r24	; 0x0b
 52a:	48 cf       	rjmp	.-368    	; 0x3bc <main+0x72>
			}
			break;
		case STATE_NORMAL:
			{
				int i;
				for(i=0; i<NUM_POINTS; ++i){
 52c:	1c 82       	std	Y+4, r1	; 0x04
 52e:	1b 82       	std	Y+3, r1	; 0x03
 530:	7e c0       	rjmp	.+252    	; 0x62e <__stack+0x1cf>
					UpdatePointState(g_points+i);
 532:	2b 81       	ldd	r18, Y+3	; 0x03
 534:	3c 81       	ldd	r19, Y+4	; 0x04
 536:	c9 01       	movw	r24, r18
 538:	88 0f       	add	r24, r24
 53a:	99 1f       	adc	r25, r25
 53c:	88 0f       	add	r24, r24
 53e:	99 1f       	adc	r25, r25
 540:	82 0f       	add	r24, r18
 542:	93 1f       	adc	r25, r19
 544:	8e 59       	subi	r24, 0x9E	; 158
 546:	9f 4f       	sbci	r25, 0xFF	; 255
 548:	0e 94 ab 00 	call	0x156	; 0x156 <UpdatePointState>
					if(i%4==3){
 54c:	8b 81       	ldd	r24, Y+3	; 0x03
 54e:	9c 81       	ldd	r25, Y+4	; 0x04
 550:	24 e0       	ldi	r18, 0x04	; 4
 552:	30 e0       	ldi	r19, 0x00	; 0
 554:	b9 01       	movw	r22, r18
 556:	0e 94 59 03 	call	0x6b2	; 0x6b2 <__divmodhi4>
 55a:	83 30       	cpi	r24, 0x03	; 3
 55c:	91 05       	cpc	r25, r1
 55e:	09 f0       	breq	.+2      	; 0x562 <__stack+0x103>
 560:	61 c0       	rjmp	.+194    	; 0x624 <__stack+0x1c5>
						unsigned char v = ( (1<<7) >> (i/4) );
 562:	8b 81       	ldd	r24, Y+3	; 0x03
 564:	9c 81       	ldd	r25, Y+4	; 0x04
 566:	9f 87       	std	Y+15, r25	; 0x0f
 568:	8e 87       	std	Y+14, r24	; 0x0e
 56a:	2e 85       	ldd	r18, Y+14	; 0x0e
 56c:	3f 85       	ldd	r19, Y+15	; 0x0f
 56e:	33 23       	and	r19, r19
 570:	34 f4       	brge	.+12     	; 0x57e <__stack+0x11f>
 572:	4e 85       	ldd	r20, Y+14	; 0x0e
 574:	5f 85       	ldd	r21, Y+15	; 0x0f
 576:	4d 5f       	subi	r20, 0xFD	; 253
 578:	5f 4f       	sbci	r21, 0xFF	; 255
 57a:	5f 87       	std	Y+15, r21	; 0x0f
 57c:	4e 87       	std	Y+14, r20	; 0x0e
 57e:	8e 85       	ldd	r24, Y+14	; 0x0e
 580:	9f 85       	ldd	r25, Y+15	; 0x0f
 582:	95 95       	asr	r25
 584:	87 95       	ror	r24
 586:	95 95       	asr	r25
 588:	87 95       	ror	r24
 58a:	9c 01       	movw	r18, r24
 58c:	80 e8       	ldi	r24, 0x80	; 128
 58e:	90 e0       	ldi	r25, 0x00	; 0
 590:	02 2e       	mov	r0, r18
 592:	02 c0       	rjmp	.+4      	; 0x598 <__stack+0x139>
 594:	95 95       	asr	r25
 596:	87 95       	ror	r24
 598:	0a 94       	dec	r0
 59a:	e2 f7       	brpl	.-8      	; 0x594 <__stack+0x135>
 59c:	8a 83       	std	Y+2, r24	; 0x02
						{
							signed char j;
							for(j=3;j>=0;--j) {
 59e:	83 e0       	ldi	r24, 0x03	; 3
 5a0:	89 83       	std	Y+1, r24	; 0x01
 5a2:	30 c0       	rjmp	.+96     	; 0x604 <__stack+0x1a5>
								if(g_points[i-j].m_flags & POINT_IS_WHITE_BIT)
 5a4:	89 81       	ldd	r24, Y+1	; 0x01
 5a6:	28 2f       	mov	r18, r24
 5a8:	33 27       	eor	r19, r19
 5aa:	27 fd       	sbrc	r18, 7
 5ac:	30 95       	com	r19
 5ae:	8b 81       	ldd	r24, Y+3	; 0x03
 5b0:	9c 81       	ldd	r25, Y+4	; 0x04
 5b2:	ac 01       	movw	r20, r24
 5b4:	42 1b       	sub	r20, r18
 5b6:	53 0b       	sbc	r21, r19
 5b8:	9a 01       	movw	r18, r20
 5ba:	c9 01       	movw	r24, r18
 5bc:	88 0f       	add	r24, r24
 5be:	99 1f       	adc	r25, r25
 5c0:	88 0f       	add	r24, r24
 5c2:	99 1f       	adc	r25, r25
 5c4:	82 0f       	add	r24, r18
 5c6:	93 1f       	adc	r25, r19
 5c8:	fc 01       	movw	r30, r24
 5ca:	ea 59       	subi	r30, 0x9A	; 154
 5cc:	ff 4f       	sbci	r31, 0xFF	; 255
 5ce:	80 81       	ld	r24, Z
 5d0:	88 2f       	mov	r24, r24
 5d2:	90 e0       	ldi	r25, 0x00	; 0
 5d4:	81 70       	andi	r24, 0x01	; 1
 5d6:	90 70       	andi	r25, 0x00	; 0
 5d8:	88 23       	and	r24, r24
 5da:	89 f0       	breq	.+34     	; 0x5fe <__stack+0x19f>
								{
									v|=1<<j;
 5dc:	89 81       	ldd	r24, Y+1	; 0x01
 5de:	28 2f       	mov	r18, r24
 5e0:	33 27       	eor	r19, r19
 5e2:	27 fd       	sbrc	r18, 7
 5e4:	30 95       	com	r19
 5e6:	81 e0       	ldi	r24, 0x01	; 1
 5e8:	90 e0       	ldi	r25, 0x00	; 0
 5ea:	02 2e       	mov	r0, r18
 5ec:	02 c0       	rjmp	.+4      	; 0x5f2 <__stack+0x193>
 5ee:	88 0f       	add	r24, r24
 5f0:	99 1f       	adc	r25, r25
 5f2:	0a 94       	dec	r0
 5f4:	e2 f7       	brpl	.-8      	; 0x5ee <__stack+0x18f>
 5f6:	98 2f       	mov	r25, r24
 5f8:	8a 81       	ldd	r24, Y+2	; 0x02
 5fa:	89 2b       	or	r24, r25
 5fc:	8a 83       	std	Y+2, r24	; 0x02
					UpdatePointState(g_points+i);
					if(i%4==3){
						unsigned char v = ( (1<<7) >> (i/4) );
						{
							signed char j;
							for(j=3;j>=0;--j) {
 5fe:	89 81       	ldd	r24, Y+1	; 0x01
 600:	81 50       	subi	r24, 0x01	; 1
 602:	89 83       	std	Y+1, r24	; 0x01
 604:	89 81       	ldd	r24, Y+1	; 0x01
 606:	88 23       	and	r24, r24
 608:	6c f6       	brge	.-102    	; 0x5a4 <__stack+0x145>
								{
									v|=1<<j;
								}
							}
						}
						WriteByteToTheShiftRegister(0);
 60a:	80 e0       	ldi	r24, 0x00	; 0
 60c:	0e 94 5f 01 	call	0x2be	; 0x2be <WriteByteToTheShiftRegister>
						WriteByteToTheShiftRegister(0);
 610:	80 e0       	ldi	r24, 0x00	; 0
 612:	0e 94 5f 01 	call	0x2be	; 0x2be <WriteByteToTheShiftRegister>
						WriteByteToTheShiftRegister(v);
 616:	8a 81       	ldd	r24, Y+2	; 0x02
 618:	0e 94 5f 01 	call	0x2be	; 0x2be <WriteByteToTheShiftRegister>
						Wait(DISPLAY_WAIT);
 61c:	88 ee       	ldi	r24, 0xE8	; 232
 61e:	93 e0       	ldi	r25, 0x03	; 3
 620:	0e 94 49 00 	call	0x92	; 0x92 <Wait>
			}
			break;
		case STATE_NORMAL:
			{
				int i;
				for(i=0; i<NUM_POINTS; ++i){
 624:	8b 81       	ldd	r24, Y+3	; 0x03
 626:	9c 81       	ldd	r25, Y+4	; 0x04
 628:	01 96       	adiw	r24, 0x01	; 1
 62a:	9c 83       	std	Y+4, r25	; 0x04
 62c:	8b 83       	std	Y+3, r24	; 0x03
 62e:	8b 81       	ldd	r24, Y+3	; 0x03
 630:	9c 81       	ldd	r25, Y+4	; 0x04
 632:	80 31       	cpi	r24, 0x10	; 16
 634:	91 05       	cpc	r25, r1
 636:	0c f4       	brge	.+2      	; 0x63a <__stack+0x1db>
 638:	7c cf       	rjmp	.-264    	; 0x532 <__stack+0xd3>
 63a:	c0 ce       	rjmp	.-640    	; 0x3bc <main+0x72>

0000063c <ADProc>:
			break;
		}
	}
}

short ADProc(){
 63c:	df 93       	push	r29
 63e:	cf 93       	push	r28
 640:	cd b7       	in	r28, 0x3d	; 61
 642:	de b7       	in	r29, 0x3e	; 62
	ADCSRA |= _BV(ADSC);
 644:	a6 e2       	ldi	r26, 0x26	; 38
 646:	b0 e0       	ldi	r27, 0x00	; 0
 648:	e6 e2       	ldi	r30, 0x26	; 38
 64a:	f0 e0       	ldi	r31, 0x00	; 0
 64c:	80 81       	ld	r24, Z
 64e:	80 64       	ori	r24, 0x40	; 64
 650:	8c 93       	st	X, r24
	while(ADCSRA & _BV(ADSC))
 652:	e6 e2       	ldi	r30, 0x26	; 38
 654:	f0 e0       	ldi	r31, 0x00	; 0
 656:	80 81       	ld	r24, Z
 658:	88 2f       	mov	r24, r24
 65a:	90 e0       	ldi	r25, 0x00	; 0
 65c:	80 74       	andi	r24, 0x40	; 64
 65e:	90 70       	andi	r25, 0x00	; 0
 660:	00 97       	sbiw	r24, 0x00	; 0
 662:	b9 f7       	brne	.-18     	; 0x652 <ADProc+0x16>
		;
	return ADCH;
 664:	e5 e2       	ldi	r30, 0x25	; 37
 666:	f0 e0       	ldi	r31, 0x00	; 0
 668:	80 81       	ld	r24, Z
 66a:	88 2f       	mov	r24, r24
 66c:	90 e0       	ldi	r25, 0x00	; 0
}
 66e:	cf 91       	pop	r28
 670:	df 91       	pop	r29
 672:	08 95       	ret

00000674 <__mulsi3>:
 674:	62 9f       	mul	r22, r18
 676:	d0 01       	movw	r26, r0
 678:	73 9f       	mul	r23, r19
 67a:	f0 01       	movw	r30, r0
 67c:	82 9f       	mul	r24, r18
 67e:	e0 0d       	add	r30, r0
 680:	f1 1d       	adc	r31, r1
 682:	64 9f       	mul	r22, r20
 684:	e0 0d       	add	r30, r0
 686:	f1 1d       	adc	r31, r1
 688:	92 9f       	mul	r25, r18
 68a:	f0 0d       	add	r31, r0
 68c:	83 9f       	mul	r24, r19
 68e:	f0 0d       	add	r31, r0
 690:	74 9f       	mul	r23, r20
 692:	f0 0d       	add	r31, r0
 694:	65 9f       	mul	r22, r21
 696:	f0 0d       	add	r31, r0
 698:	99 27       	eor	r25, r25
 69a:	72 9f       	mul	r23, r18
 69c:	b0 0d       	add	r27, r0
 69e:	e1 1d       	adc	r30, r1
 6a0:	f9 1f       	adc	r31, r25
 6a2:	63 9f       	mul	r22, r19
 6a4:	b0 0d       	add	r27, r0
 6a6:	e1 1d       	adc	r30, r1
 6a8:	f9 1f       	adc	r31, r25
 6aa:	bd 01       	movw	r22, r26
 6ac:	cf 01       	movw	r24, r30
 6ae:	11 24       	eor	r1, r1
 6b0:	08 95       	ret

000006b2 <__divmodhi4>:
 6b2:	97 fb       	bst	r25, 7
 6b4:	09 2e       	mov	r0, r25
 6b6:	07 26       	eor	r0, r23
 6b8:	0a d0       	rcall	.+20     	; 0x6ce <__divmodhi4_neg1>
 6ba:	77 fd       	sbrc	r23, 7
 6bc:	04 d0       	rcall	.+8      	; 0x6c6 <__divmodhi4_neg2>
 6be:	27 d0       	rcall	.+78     	; 0x70e <__udivmodhi4>
 6c0:	06 d0       	rcall	.+12     	; 0x6ce <__divmodhi4_neg1>
 6c2:	00 20       	and	r0, r0
 6c4:	1a f4       	brpl	.+6      	; 0x6cc <__divmodhi4_exit>

000006c6 <__divmodhi4_neg2>:
 6c6:	70 95       	com	r23
 6c8:	61 95       	neg	r22
 6ca:	7f 4f       	sbci	r23, 0xFF	; 255

000006cc <__divmodhi4_exit>:
 6cc:	08 95       	ret

000006ce <__divmodhi4_neg1>:
 6ce:	f6 f7       	brtc	.-4      	; 0x6cc <__divmodhi4_exit>
 6d0:	90 95       	com	r25
 6d2:	81 95       	neg	r24
 6d4:	9f 4f       	sbci	r25, 0xFF	; 255
 6d6:	08 95       	ret

000006d8 <__divmodsi4>:
 6d8:	97 fb       	bst	r25, 7
 6da:	09 2e       	mov	r0, r25
 6dc:	05 26       	eor	r0, r21
 6de:	0e d0       	rcall	.+28     	; 0x6fc <__divmodsi4_neg1>
 6e0:	57 fd       	sbrc	r21, 7
 6e2:	04 d0       	rcall	.+8      	; 0x6ec <__divmodsi4_neg2>
 6e4:	28 d0       	rcall	.+80     	; 0x736 <__udivmodsi4>
 6e6:	0a d0       	rcall	.+20     	; 0x6fc <__divmodsi4_neg1>
 6e8:	00 1c       	adc	r0, r0
 6ea:	38 f4       	brcc	.+14     	; 0x6fa <__divmodsi4_exit>

000006ec <__divmodsi4_neg2>:
 6ec:	50 95       	com	r21
 6ee:	40 95       	com	r20
 6f0:	30 95       	com	r19
 6f2:	21 95       	neg	r18
 6f4:	3f 4f       	sbci	r19, 0xFF	; 255
 6f6:	4f 4f       	sbci	r20, 0xFF	; 255
 6f8:	5f 4f       	sbci	r21, 0xFF	; 255

000006fa <__divmodsi4_exit>:
 6fa:	08 95       	ret

000006fc <__divmodsi4_neg1>:
 6fc:	f6 f7       	brtc	.-4      	; 0x6fa <__divmodsi4_exit>
 6fe:	90 95       	com	r25
 700:	80 95       	com	r24
 702:	70 95       	com	r23
 704:	61 95       	neg	r22
 706:	7f 4f       	sbci	r23, 0xFF	; 255
 708:	8f 4f       	sbci	r24, 0xFF	; 255
 70a:	9f 4f       	sbci	r25, 0xFF	; 255
 70c:	08 95       	ret

0000070e <__udivmodhi4>:
 70e:	aa 1b       	sub	r26, r26
 710:	bb 1b       	sub	r27, r27
 712:	51 e1       	ldi	r21, 0x11	; 17
 714:	07 c0       	rjmp	.+14     	; 0x724 <__udivmodhi4_ep>

00000716 <__udivmodhi4_loop>:
 716:	aa 1f       	adc	r26, r26
 718:	bb 1f       	adc	r27, r27
 71a:	a6 17       	cp	r26, r22
 71c:	b7 07       	cpc	r27, r23
 71e:	10 f0       	brcs	.+4      	; 0x724 <__udivmodhi4_ep>
 720:	a6 1b       	sub	r26, r22
 722:	b7 0b       	sbc	r27, r23

00000724 <__udivmodhi4_ep>:
 724:	88 1f       	adc	r24, r24
 726:	99 1f       	adc	r25, r25
 728:	5a 95       	dec	r21
 72a:	a9 f7       	brne	.-22     	; 0x716 <__udivmodhi4_loop>
 72c:	80 95       	com	r24
 72e:	90 95       	com	r25
 730:	bc 01       	movw	r22, r24
 732:	cd 01       	movw	r24, r26
 734:	08 95       	ret

00000736 <__udivmodsi4>:
 736:	a1 e2       	ldi	r26, 0x21	; 33
 738:	1a 2e       	mov	r1, r26
 73a:	aa 1b       	sub	r26, r26
 73c:	bb 1b       	sub	r27, r27
 73e:	fd 01       	movw	r30, r26
 740:	0d c0       	rjmp	.+26     	; 0x75c <__udivmodsi4_ep>

00000742 <__udivmodsi4_loop>:
 742:	aa 1f       	adc	r26, r26
 744:	bb 1f       	adc	r27, r27
 746:	ee 1f       	adc	r30, r30
 748:	ff 1f       	adc	r31, r31
 74a:	a2 17       	cp	r26, r18
 74c:	b3 07       	cpc	r27, r19
 74e:	e4 07       	cpc	r30, r20
 750:	f5 07       	cpc	r31, r21
 752:	20 f0       	brcs	.+8      	; 0x75c <__udivmodsi4_ep>
 754:	a2 1b       	sub	r26, r18
 756:	b3 0b       	sbc	r27, r19
 758:	e4 0b       	sbc	r30, r20
 75a:	f5 0b       	sbc	r31, r21

0000075c <__udivmodsi4_ep>:
 75c:	66 1f       	adc	r22, r22
 75e:	77 1f       	adc	r23, r23
 760:	88 1f       	adc	r24, r24
 762:	99 1f       	adc	r25, r25
 764:	1a 94       	dec	r1
 766:	69 f7       	brne	.-38     	; 0x742 <__udivmodsi4_loop>
 768:	60 95       	com	r22
 76a:	70 95       	com	r23
 76c:	80 95       	com	r24
 76e:	90 95       	com	r25
 770:	9b 01       	movw	r18, r22
 772:	ac 01       	movw	r20, r24
 774:	bd 01       	movw	r22, r26
 776:	cf 01       	movw	r24, r30
 778:	08 95       	ret

0000077a <_exit>:
 77a:	f8 94       	cli

0000077c <__stop_program>:
 77c:	ff cf       	rjmp	.-2      	; 0x77c <__stop_program>
